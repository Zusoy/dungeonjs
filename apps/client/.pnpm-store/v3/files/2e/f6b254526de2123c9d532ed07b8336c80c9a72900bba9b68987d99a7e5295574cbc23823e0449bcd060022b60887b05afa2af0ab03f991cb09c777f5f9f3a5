import { computed, signal } from '@preact/signals-core';
import { FlexNode, createFlexNodeState } from '../flex/index.js';
import { setupLayoutListeners } from '../listeners.js';
import { createInstancedPanel } from '../panel/instanced-panel.js';
import { PanelGroupManager, computedPanelGroupDependencies, } from '../panel/instanced-panel-group.js';
import { applyScrollPosition, computedGlobalScrollMatrix, createScrollPosition, createScrollbars, computedScrollHandlers, } from '../scroll.js';
import { applyTransform, computedTransformMatrix } from '../transform.js';
import { alignmentXMap, alignmentYMap, readReactive } from '../utils.js';
import { computeAncestorsHaveListeners, computeDefaultProperties, computedHandlers, computedIsVisible, computedMergedProperties, setupMatrixWorldUpdate, setupPointerEvents, } from './utils.js';
import { computedClippingRect } from '../clipping.js';
import { computedOrderInfo, ElementType } from '../order.js';
import { Matrix4, Plane, Vector3 } from 'three';
import { GlyphGroupManager } from '../text/render/instanced-glyph-group.js';
import { createActivePropertyTransfomers } from '../active.js';
import { createHoverPropertyTransformers, setupCursorCleanup } from '../hover.js';
import { createInteractionPanel } from '../panel/instanced-panel-mesh.js';
import { createResponsivePropertyTransformers } from '../responsive.js';
import { darkPropertyTransformers } from '../dark.js';
import { computedInheritableProperty } from '../properties/index.js';
import { getDefaultPanelMaterialConfig } from '../panel/index.js';
export const DEFAULT_PIXEL_SIZE = 0.01;
const vectorHelper = new Vector3();
const planeHelper = new Plane();
const identityMatrix = signal(new Matrix4());
export function createRoot(pixelSize, style, properties, defaultProperties, object, childrenContainer, getCamera, renderer, onFrameSet, requestRender = () => { }, requestFrame = () => { }) {
    const rootSize = signal([0, 0]);
    const hoveredSignal = signal([]);
    const activeSignal = signal([]);
    const interactableDescendants = [];
    const initializers = [
        () => {
            if (object.current != null) {
                object.current.interactableDescendants = interactableDescendants;
            }
            return () => { };
        },
    ];
    setupCursorCleanup(hoveredSignal, initializers);
    const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
        ...darkPropertyTransformers,
        ...createResponsivePropertyTransformers(rootSize),
        ...createHoverPropertyTransformers(hoveredSignal),
        ...createActivePropertyTransfomers(activeSignal),
    }, {
        ...createSizeTranslator(pixelSize, 'sizeX', 'width'),
        ...createSizeTranslator(pixelSize, 'sizeY', 'height'),
    });
    const ctx = {
        cameraDistance: 0,
        onFrameSet,
        requestRender,
        requestFrame,
        pixelSize,
    };
    const node = signal(undefined);
    const requestCalculateLayout = createDeferredRequestLayoutCalculation(ctx, node, initializers);
    const flexState = createFlexNodeState();
    initializers.push((subscriptions) => {
        const newNode = new FlexNode(flexState, mergedProperties, requestCalculateLayout, object, true, subscriptions);
        node.value = newNode;
        return subscriptions;
    });
    const transformMatrix = computedTransformMatrix(mergedProperties, flexState, pixelSize);
    const globalMatrix = computedRootMatrix(mergedProperties, transformMatrix, flexState.size, pixelSize);
    //rootMatrix is automatically applied to everything, even the instanced things because everything is part of object
    applyTransform(ctx, object, globalMatrix, initializers);
    const groupDeps = computedPanelGroupDependencies(mergedProperties);
    const orderInfo = computedOrderInfo(undefined, ElementType.Panel, groupDeps, undefined);
    const panelGroupManager = new PanelGroupManager(pixelSize, ctx, object, initializers);
    const onCameraDistanceFrame = () => {
        if (object.current == null) {
            ctx.cameraDistance = 0;
            return;
        }
        planeHelper.normal.set(0, 0, 1);
        planeHelper.constant = 0;
        planeHelper.applyMatrix4(object.current.matrixWorld);
        vectorHelper.setFromMatrixPosition(getCamera().matrixWorld);
        ctx.cameraDistance = planeHelper.distanceToPoint(vectorHelper);
    };
    initializers.push(() => {
        onFrameSet.add(onCameraDistanceFrame);
        return () => onFrameSet.delete(onCameraDistanceFrame);
    });
    const isVisible = computedIsVisible(flexState, undefined, mergedProperties);
    initializers.push((subscriptions) => createInstancedPanel(mergedProperties, orderInfo, groupDeps, panelGroupManager, identityMatrix, flexState.size, undefined, flexState.borderInset, undefined, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
    const scrollPosition = createScrollPosition();
    applyScrollPosition(childrenContainer, scrollPosition, pixelSize, initializers);
    const childrenMatrix = computedGlobalScrollMatrix(scrollPosition, identityMatrix, pixelSize);
    const scrollbarWidth = computedInheritableProperty(mergedProperties, 'scrollbarWidth', 10);
    createScrollbars(mergedProperties, scrollPosition, flexState, identityMatrix, isVisible, undefined, orderInfo, panelGroupManager, scrollbarWidth, initializers);
    setupLayoutListeners(style, properties, flexState.size, initializers);
    const gylphGroupManager = new GlyphGroupManager(pixelSize, ctx, object, initializers);
    const rootCtx = Object.assign(ctx, {
        objectInvertedWorldMatrix: new Matrix4(),
        rayInGlobalSpaceMap: new Map(),
        interactableDescendants,
        onUpdateMatrixWorldSet: new Set(),
        requestFrame,
        scrollPosition,
        requestCalculateLayout,
        cameraDistance: 0,
        gylphGroupManager,
        object,
        panelGroupManager,
        pixelSize,
        renderer,
        size: flexState.size,
    });
    const interactionPanel = createInteractionPanel(orderInfo, rootCtx, undefined, flexState.size, globalMatrix, initializers);
    //setup matrix world updates
    initializers.push(() => {
        if (childrenContainer.current != null) {
            childrenContainer.current.updateMatrixWorld = function () {
                if (this.parent == null) {
                    this.matrixWorld.copy(this.matrix);
                }
                else {
                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                }
                for (const update of rootCtx.onUpdateMatrixWorldSet) {
                    update();
                }
            };
        }
        return () => { };
    });
    const updateMatrixWorld = computedInheritableProperty(mergedProperties, 'updateMatrixWorld', false);
    setupMatrixWorldUpdate(updateMatrixWorld, false, interactionPanel, rootCtx, globalMatrix, initializers, true);
    const scrollHandlers = computedScrollHandlers(scrollPosition, undefined, flexState, object, scrollbarWidth, properties, ctx, initializers);
    const handlers = computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, scrollHandlers);
    const ancestorsHaveListeners = computeAncestorsHaveListeners(undefined, handlers);
    setupPointerEvents(mergedProperties, ancestorsHaveListeners, rootCtx, interactionPanel, initializers, false);
    return Object.assign(flexState, {
        ancestorsHaveListeners,
        defaultProperties: computeDefaultProperties(mergedProperties),
        globalMatrix,
        isVisible,
        scrollPosition,
        mergedProperties,
        anyAncestorScrollable: flexState.scrollable,
        clippingRect: computedClippingRect(identityMatrix, flexState, pixelSize, undefined),
        childrenMatrix,
        node,
        orderInfo,
        initializers,
        interactionPanel,
        handlers,
        root: rootCtx,
    });
}
function createDeferredRequestLayoutCalculation(root, nodeSignal, initializers) {
    let requested = false;
    const onFrame = () => {
        const node = nodeSignal.peek();
        if (!requested || node == null) {
            return;
        }
        requested = false;
        node.calculateLayout();
    };
    initializers.push(() => {
        root.onFrameSet.add(onFrame);
        return () => root.onFrameSet.delete(onFrame);
    });
    return () => {
        requested = true;
        root.requestRender();
    };
}
function createSizeTranslator(pixelSize, key, to) {
    const map = new Map();
    return {
        [key]: (value, target) => {
            let entry = map.get(value);
            if (entry == null) {
                map.set(value, (entry = computed(() => {
                    const s = readReactive(value);
                    if (s == null) {
                        return undefined;
                    }
                    return s / pixelSize.value;
                })));
            }
            target.add(to, entry);
        },
    };
}
const matrixHelper = new Matrix4();
const defaultAnchorX = 'center';
const defaultAnchorY = 'center';
function computedRootMatrix(propertiesSignal, matrix, size, pixelSize) {
    const anchorX = computedInheritableProperty(propertiesSignal, 'anchorX', defaultAnchorX);
    const anchorY = computedInheritableProperty(propertiesSignal, 'anchorY', defaultAnchorY);
    return computed(() => {
        if (size.value == null) {
            return undefined;
        }
        const [width, height] = size.value;
        return matrix.value
            ?.clone()
            .premultiply(matrixHelper.makeTranslation(alignmentXMap[anchorX.value] * width * pixelSize.value, alignmentYMap[anchorY.value] * height * pixelSize.value, 0));
    });
}
