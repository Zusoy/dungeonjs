import { computed, effect, signal } from '@preact/signals-core';
import { Mesh, MeshBasicMaterial, SRGBColorSpace, Texture, TextureLoader, } from 'three';
import { createFlexNodeState } from '../flex/index.js';
import { ElementType, computedOrderInfo, setupRenderOrder } from '../order.js';
import { PanelDepthMaterial, PanelDistanceMaterial, createPanelMaterial, createPanelMaterialConfig, panelGeometry, } from '../panel/index.js';
import { applyScrollPosition, computedGlobalScrollMatrix, createScrollPosition, createScrollbars, computedScrollHandlers, computedAnyAncestorScrollable, } from '../scroll.js';
import { applyTransform, computedTransformMatrix } from '../transform.js';
import { computeAncestorsHaveListeners, computeDefaultProperties, computedGlobalMatrix, computedHandlers, computedIsVisible, computedMergedProperties, createNode, keepAspectRatioPropertyTransformer, loadResourceWithParams, setupMatrixWorldUpdate, setupPointerEvents, } from './utils.js';
import { readReactive, unsubscribeSubscriptions } from '../utils.js';
import { setupImmediateProperties } from '../properties/immediate.js';
import { computedBoundingSphere, makeClippedCast, makePanelRaycast, makePanelSpherecast, } from '../panel/interaction-panel-mesh.js';
import { computedIsClipped, computedClippingRect, createGlobalClippingPlanes } from '../clipping.js';
import { setupLayoutListeners, setupClippedListeners } from '../listeners.js';
import { computedInheritableProperty } from '../properties/utils.js';
import { createActivePropertyTransfomers } from '../active.js';
import { createHoverPropertyTransformers, setupCursorCleanup } from '../hover.js';
import { createResponsivePropertyTransformers } from '../responsive.js';
import { darkPropertyTransformers } from '../dark.js';
const defaultImageFit = 'fill';
export function createImage(parentCtx, style, properties, defaultProperties, object, childrenContainer) {
    const initializers = [];
    const texture = signal(undefined);
    const hoveredSignal = signal([]);
    const activeSignal = signal([]);
    setupCursorCleanup(hoveredSignal, initializers);
    const src = computed(() => readReactive(style.value?.src) ?? readReactive(properties.value?.src));
    loadResourceWithParams(texture, loadTextureImpl, cleanupTexture, initializers, src);
    const textureAspectRatio = computed(() => {
        const tex = texture.value;
        if (tex == null) {
            return undefined;
        }
        const image = tex.source.data;
        return image.width / image.height;
    });
    const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
        ...darkPropertyTransformers,
        ...createResponsivePropertyTransformers(parentCtx.root.size),
        ...createHoverPropertyTransformers(hoveredSignal),
        ...createActivePropertyTransfomers(activeSignal),
    }, keepAspectRatioPropertyTransformer, (m) => m.add('aspectRatio', textureAspectRatio));
    const node = signal(undefined);
    const flexState = createFlexNodeState();
    createNode(node, flexState, parentCtx, mergedProperties, object, true, initializers);
    const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentCtx.root.pixelSize);
    applyTransform(parentCtx.root, object, transformMatrix, initializers);
    const globalMatrix = computedGlobalMatrix(parentCtx.childrenMatrix, transformMatrix);
    const isClipped = computedIsClipped(parentCtx.clippingRect, globalMatrix, flexState.size, parentCtx.root.pixelSize);
    const isHidden = computed(() => isClipped.value || texture.value == null);
    const isVisible = computedIsVisible(flexState, isHidden, mergedProperties);
    const orderInfo = computedOrderInfo(mergedProperties, ElementType.Image, undefined, parentCtx.orderInfo);
    const scrollPosition = createScrollPosition();
    applyScrollPosition(childrenContainer, scrollPosition, parentCtx.root.pixelSize, initializers);
    const childrenMatrix = computedGlobalScrollMatrix(scrollPosition, globalMatrix, parentCtx.root.pixelSize);
    const scrollbarWidth = computedInheritableProperty(mergedProperties, 'scrollbarWidth', 10);
    createScrollbars(mergedProperties, scrollPosition, flexState, globalMatrix, isVisible, parentCtx.clippingRect, orderInfo, parentCtx.root.panelGroupManager, scrollbarWidth, initializers);
    const scrollHandlers = computedScrollHandlers(scrollPosition, parentCtx.anyAncestorScrollable, flexState, object, scrollbarWidth, properties, parentCtx.root, initializers);
    const imageMesh = createImageMesh(mergedProperties, texture, globalMatrix, parentCtx, flexState, orderInfo, parentCtx.root, isVisible, initializers);
    const handlers = computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, scrollHandlers);
    const ancestorsHaveListeners = computeAncestorsHaveListeners(parentCtx, handlers);
    setupPointerEvents(mergedProperties, ancestorsHaveListeners, parentCtx.root, imageMesh, initializers, false);
    const updateMatrixWorld = computedInheritableProperty(mergedProperties, 'updateMatrixWorld', false);
    setupMatrixWorldUpdate(updateMatrixWorld, false, object, parentCtx.root, globalMatrix, initializers, false);
    setupMatrixWorldUpdate(true, false, imageMesh, parentCtx.root, globalMatrix, initializers, true);
    setupLayoutListeners(style, properties, flexState.size, initializers);
    setupClippedListeners(style, properties, isClipped, initializers);
    return Object.assign(flexState, {
        ancestorsHaveListeners,
        defaultProperties: computeDefaultProperties(mergedProperties),
        globalMatrix,
        scrollPosition,
        isClipped,
        isVisible,
        mergedProperties,
        anyAncestorScrollable: computedAnyAncestorScrollable(flexState.scrollable, parentCtx.anyAncestorScrollable),
        initializers,
        handlers,
        interactionPanel: imageMesh,
        clippingRect: computedClippingRect(globalMatrix, flexState, parentCtx.root.pixelSize, parentCtx.clippingRect),
        childrenMatrix,
        node,
        orderInfo,
        root: parentCtx.root,
    });
}
let imageMaterialConfig;
function getImageMaterialConfig() {
    imageMaterialConfig ??= createPanelMaterialConfig({
        borderBend: 'borderBend',
        borderBottomLeftRadius: 'borderBottomLeftRadius',
        borderBottomRightRadius: 'borderBottomRightRadius',
        borderColor: 'borderColor',
        borderOpacity: 'borderOpacity',
        borderTopLeftRadius: 'borderTopLeftRadius',
        borderTopRightRadius: 'borderTopRightRadius',
        backgroundOpacity: 'opacity',
    }, {
        backgroundColor: 0xffffff,
    });
    return imageMaterialConfig;
}
function createImageMesh(propertiesSignal, textureSignal, globalMatrix, parentContext, flexState, orderInfo, root, isVisible, initializers) {
    const mesh = new Mesh(panelGeometry);
    mesh.matrixAutoUpdate = false;
    const clippingPlanes = createGlobalClippingPlanes(root, parentContext.clippingRect);
    const isMeshVisible = getImageMaterialConfig().computedIsVisibile(propertiesSignal, flexState.borderInset, flexState.size, isVisible);
    setupImageMaterials(propertiesSignal, textureSignal, mesh, flexState.size, flexState.borderInset, isMeshVisible, clippingPlanes, root, initializers);
    const boundingSphere = computedBoundingSphere(parentContext.root.pixelSize, globalMatrix, flexState.size, initializers);
    initializers.push(() => {
        const rootObjectMatrixWorld = root.object.current?.matrixWorld;
        if (rootObjectMatrixWorld != null) {
            mesh.raycast = makeClippedCast(mesh, makePanelRaycast(mesh.raycast.bind(mesh), rootObjectMatrixWorld, boundingSphere, globalMatrix, mesh), root.object, parentContext.clippingRect, orderInfo);
            mesh.spherecast = makeClippedCast(mesh, makePanelSpherecast(rootObjectMatrixWorld, boundingSphere, globalMatrix, mesh), root.object, parentContext.clippingRect, orderInfo);
        }
        return () => { };
    });
    setupRenderOrder(mesh, root, orderInfo);
    const objectFit = computedInheritableProperty(propertiesSignal, 'objectFit', defaultImageFit);
    initializers.push(() => effect(() => {
        const texture = textureSignal.value;
        if (texture == null || flexState.size.value == null || flexState.borderInset.value == null) {
            return;
        }
        texture.matrix.identity();
        root.requestRender();
        if (objectFit.value === 'fill' || texture == null) {
            transformInsideBorder(flexState.borderInset, flexState.size, texture);
            return;
        }
        const { width: textureWidth, height: textureHeight } = texture.source.data;
        const textureRatio = textureWidth / textureHeight;
        const [width, height] = flexState.size.value;
        const [top, right, bottom, left] = flexState.borderInset.value;
        const boundsRatioValue = (width - left - right) / (height - top - bottom);
        if (textureRatio > boundsRatioValue) {
            texture.matrix
                .translate(-(0.5 * (boundsRatioValue - textureRatio)) / boundsRatioValue, 0)
                .scale(boundsRatioValue / textureRatio, 1);
        }
        else {
            texture.matrix
                .translate(0, -(0.5 * (textureRatio - boundsRatioValue)) / textureRatio)
                .scale(1, textureRatio / boundsRatioValue);
        }
        transformInsideBorder(flexState.borderInset, flexState.size, texture);
    }), () => effect(() => {
        mesh.visible = isMeshVisible.value;
        parentContext.root.requestRender();
    }), () => effect(() => {
        if (flexState.size.value == null) {
            return;
        }
        const [width, height] = flexState.size.value;
        const pixelSize = parentContext.root.pixelSize.value;
        mesh.scale.set(width * pixelSize, height * pixelSize, 1);
        mesh.updateMatrix();
        parentContext.root.requestRender();
    }));
    return mesh;
}
function transformInsideBorder(borderInset, size, texture) {
    if (size.value == null || borderInset.value == null) {
        return;
    }
    const [outerWidth, outerHeight] = size.value;
    const [top, right, bottom, left] = borderInset.value;
    const width = outerWidth - left - right;
    const height = outerHeight - top - bottom;
    texture.matrix
        .translate(-1 + (left + width) / outerWidth, -1 + (top + height) / outerHeight)
        .scale(outerWidth / width, outerHeight / height);
}
const textureLoader = new TextureLoader();
function cleanupTexture(texture) {
    if (texture?.disposable === true) {
        texture.dispose();
    }
}
async function loadTextureImpl(src) {
    if (src == null) {
        return Promise.resolve(undefined);
    }
    if (src instanceof Texture) {
        return Promise.resolve(src);
    }
    try {
        const texture = await textureLoader.loadAsync(src);
        texture.colorSpace = SRGBColorSpace;
        texture.matrixAutoUpdate = false;
        return Object.assign(texture, { disposable: true });
    }
    catch (error) {
        console.error(error);
        return undefined;
    }
}
function setupImageMaterials(propertiesSignal, textureSignal, target, size, borderInset, isVisible, clippingPlanes, root, initializers) {
    const data = new Float32Array(16);
    const info = { data: data, type: 'normal' };
    target.customDepthMaterial = new PanelDepthMaterial(info);
    target.customDistanceMaterial = new PanelDistanceMaterial(info);
    target.customDepthMaterial.clippingPlanes = clippingPlanes;
    target.customDistanceMaterial.clippingPlanes = clippingPlanes;
    initializers.push((subscriptions) => {
        subscriptions.push(effect(() => {
            const material = createPanelMaterial(propertiesSignal.value.read('panelMaterialClass', MeshBasicMaterial), info);
            material.clippingPlanes = clippingPlanes;
            target.material = material;
            const cleanupDepthTestEffect = effect(() => {
                material.depthTest = propertiesSignal.value.read('depthTest', true);
                root.requestRender();
            });
            const cleanupDepthWriteEffect = effect(() => {
                material.depthWrite = propertiesSignal.value.read('depthWrite', false);
                root.requestRender();
            });
            const cleanupTextureEffect = effect(() => {
                ;
                material.map = textureSignal.value ?? null;
                material.needsUpdate = true;
                root.requestRender();
            });
            return () => {
                cleanupTextureEffect();
                cleanupDepthWriteEffect();
                cleanupDepthTestEffect();
                material.dispose();
            };
        }), effect(() => {
            target.renderOrder = propertiesSignal.value.read('renderOrder', 0);
            root.requestRender();
        }), effect(() => {
            target.castShadow = propertiesSignal.value.read('castShadow', false);
            root.requestRender();
        }), effect(() => {
            target.receiveShadow = propertiesSignal.value.read('receiveShadow', false);
            root.requestRender();
        }));
        return subscriptions;
    });
    const imageMaterialConfig = getImageMaterialConfig();
    const internalSubscriptions = [];
    initializers.push(() => effect(() => {
        if (!isVisible.value) {
            return;
        }
        data.set(imageMaterialConfig.defaultData);
        internalSubscriptions.push(effect(() => void (size.value != null && data.set(size.value, 13))), effect(() => void (borderInset.value != null && data.set(borderInset.value, 0))));
        root.requestRender();
        return () => unsubscribeSubscriptions(internalSubscriptions);
    }));
    const setters = imageMaterialConfig.setters;
    initializers.push((subscriptions) => {
        setupImmediateProperties(propertiesSignal, isVisible, imageMaterialConfig.hasProperty, (key, value) => {
            setters[key](data, 0, value, size, undefined);
            root.requestRender();
        }, subscriptions);
        return subscriptions;
    });
}
