import { createFlexNodeState } from '../flex/node.js';
import { createHoverPropertyTransformers, setupCursorCleanup } from '../hover.js';
import { computedIsClipped, createGlobalClippingPlanes } from '../clipping.js';
import { applyTransform, computedTransformMatrix } from '../transform.js';
import { createResponsivePropertyTransformers } from '../responsive.js';
import { ElementType, computedOrderInfo, setupRenderOrder } from '../order.js';
import { createActivePropertyTransfomers } from '../active.js';
import { effect, signal } from '@preact/signals-core';
import { computeAncestorsHaveListeners, computedGlobalMatrix, computedHandlers, computedIsVisible, computedMergedProperties, createNode, setupMatrixWorldUpdate, setupPointerEvents, } from './utils.js';
import { setupLayoutListeners, setupClippedListeners } from '../listeners.js';
import { FrontSide, Material } from 'three';
import { darkPropertyTransformers } from '../dark.js';
import { makeClippedCast } from '../panel/index.js';
export function createCustomContainer(parentCtx, style, properties, defaultProperties, object, meshRef) {
    const hoveredSignal = signal([]);
    const activeSignal = signal([]);
    const initializers = [];
    setupCursorCleanup(hoveredSignal, initializers);
    //properties
    const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
        ...darkPropertyTransformers,
        ...createResponsivePropertyTransformers(parentCtx.root.size),
        ...createHoverPropertyTransformers(hoveredSignal),
        ...createActivePropertyTransfomers(activeSignal),
    });
    //create node
    const flexState = createFlexNodeState();
    createNode(undefined, flexState, parentCtx, mergedProperties, object, true, initializers);
    //transform
    const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentCtx.root.pixelSize);
    applyTransform(parentCtx.root, object, transformMatrix, initializers);
    const globalMatrix = computedGlobalMatrix(parentCtx.childrenMatrix, transformMatrix);
    const isClipped = computedIsClipped(parentCtx.clippingRect, globalMatrix, flexState.size, parentCtx.root.pixelSize);
    const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
    //instanced panel
    const orderInfo = computedOrderInfo(mergedProperties, ElementType.Custom, undefined, parentCtx.orderInfo);
    const clippingPlanes = createGlobalClippingPlanes(parentCtx.root, parentCtx.clippingRect);
    initializers.push((subscriptions) => {
        const mesh = meshRef.current;
        if (mesh == null) {
            return subscriptions;
        }
        mesh.matrixAutoUpdate = false;
        if (mesh.material instanceof Material) {
            const material = mesh.material;
            material.clippingPlanes = clippingPlanes;
            material.needsUpdate = true;
            material.shadowSide = FrontSide;
            subscriptions.push(() => effect(() => {
                material.depthTest = mergedProperties.value.read('depthTest', true);
                parentCtx.root.requestRender();
            }), () => effect(() => {
                material.depthWrite = mergedProperties.value.read('depthWrite', false);
                parentCtx.root.requestRender();
            }));
        }
        mesh.raycast = makeClippedCast(mesh, mesh.raycast, parentCtx.root.object, parentCtx.clippingRect, orderInfo);
        setupRenderOrder(mesh, parentCtx.root, orderInfo);
        subscriptions.push(effect(() => {
            mesh.renderOrder = mergedProperties.value.read('renderOrder', 0);
            parentCtx.root.requestRender();
        }), effect(() => {
            mesh.receiveShadow = mergedProperties.value.read('receiveShadow', false);
            parentCtx.root.requestRender();
        }), effect(() => {
            mesh.castShadow = mergedProperties.value.read('castShadow', false);
            parentCtx.root.requestRender();
        }), effect(() => {
            if (flexState.size.value == null) {
                return;
            }
            const [width, height] = flexState.size.value;
            const pixelSize = parentCtx.root.pixelSize.value;
            mesh.scale.set(width * pixelSize, height * pixelSize, 1);
            mesh.updateMatrix();
            parentCtx.root.requestRender();
        }), effect(() => {
            void (mesh.visible = isVisible.value);
            parentCtx.root.requestRender();
        }));
        return subscriptions;
    });
    setupMatrixWorldUpdate(true, true, object, parentCtx.root, globalMatrix, initializers, false);
    const handlers = computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal);
    const ancestorsHaveListeners = computeAncestorsHaveListeners(parentCtx, handlers);
    setupPointerEvents(mergedProperties, ancestorsHaveListeners, parentCtx.root, object, initializers, true);
    setupLayoutListeners(style, properties, flexState.size, initializers);
    setupClippedListeners(style, properties, isClipped, initializers);
    return Object.assign(flexState, {
        globalMatrix,
        isClipped,
        isVisible,
        mergedProperties,
        root: parentCtx.root,
        handlers,
        initializers,
    });
}
