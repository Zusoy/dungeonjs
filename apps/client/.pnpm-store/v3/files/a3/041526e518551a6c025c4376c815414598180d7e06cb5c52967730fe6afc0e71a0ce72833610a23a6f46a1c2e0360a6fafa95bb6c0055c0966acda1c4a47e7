import { Matrix4, Plane, Sphere, Vector2, Vector3 } from 'three';
import { effect } from '@preact/signals-core';
import { computeMatrixWorld } from '../internals.js';
import { clamp } from 'three/src/math/MathUtils.js';
const planeHelper = new Plane();
const vectorHelper = new Vector3();
const sphereHelper = new Sphere();
const matrixHelper = new Matrix4();
export function makePanelSpherecast(rootObjectMatrixWorld, globalSphereWithLocalScale, globalMatrixSignal, object) {
    return (sphere, intersects) => {
        sphereHelper.copy(globalSphereWithLocalScale).applyMatrix4(rootObjectMatrixWorld);
        if (!sphereHelper.intersectsSphere(sphere) ||
            !computeMatrixWorld(object.matrixWorld, object.matrix, rootObjectMatrixWorld, globalMatrixSignal)) {
            return;
        }
        vectorHelper.copy(sphere.center).applyMatrix4(matrixHelper.copy(object.matrixWorld).invert());
        vectorHelper.x = clamp(vectorHelper.x, -0.5, 0.5);
        vectorHelper.y = clamp(vectorHelper.y, -0.5, 0.5);
        vectorHelper.z = 0;
        const uv = new Vector2(vectorHelper.x, vectorHelper.y);
        vectorHelper.applyMatrix4(object.matrixWorld);
        const distance = sphere.center.distanceTo(vectorHelper);
        if (distance > sphere.radius) {
            return;
        }
        intersects.push({
            distance,
            object,
            point: vectorHelper.clone(),
            uv,
            normal: new Vector3(0, 0, 1),
        });
    };
}
export function makePanelRaycast(raycast, rootObjectMatrixWorld, globalSphereWithLocalScale, globalMatrixSignal, object) {
    return (raycaster, intersects) => {
        sphereHelper.copy(globalSphereWithLocalScale).applyMatrix4(rootObjectMatrixWorld);
        if (!raycaster.ray.intersectsSphere(sphereHelper) ||
            !computeMatrixWorld(object.matrixWorld, object.matrix, rootObjectMatrixWorld, globalMatrixSignal)) {
            return;
        }
        raycast(raycaster, intersects);
    };
}
export function isInteractionPanel(object) {
    return 'isInteractionPanel' in object;
}
export function computedBoundingSphere(pixelSize, globalMatrixSignal, size, initializers) {
    const sphere = new Sphere();
    initializers.push(() => effect(() => {
        const sizeValue = size.value;
        const globalMatrix = globalMatrixSignal.value;
        if (sizeValue == null || globalMatrix == null) {
            return;
        }
        sphere.center.set(0, 0, 0);
        const [w, h] = sizeValue;
        const maxDiameter = Math.sqrt(w * w + h * h);
        sphere.radius = maxDiameter * 0.5 * pixelSize.value;
        sphere.applyMatrix4(globalMatrix);
    }));
    return sphere;
}
/**
 * clips the sphere / raycast
 * also marks the mesh as a interaction panel
 */
export function makeClippedCast(mesh, fn, rootObjectRef, clippingRect, orderInfoSignal) {
    Object.assign(mesh, { isInteractionPanel: true });
    return (raycaster, intersects) => {
        const oldLength = intersects.length;
        fn.call(mesh, raycaster, intersects);
        if (oldLength === intersects.length) {
            return;
        }
        const rootObject = rootObjectRef.current;
        const orderInfo = orderInfoSignal.peek();
        if (rootObject == null || orderInfo == null) {
            return;
        }
        const clippingPlanes = clippingRect?.peek()?.planes;
        const rootMatrixWorld = rootObject.matrixWorld;
        outer: for (let i = intersects.length - 1; i >= oldLength; i--) {
            const intersection = intersects[i];
            intersection.distance -=
                orderInfo.majorIndex * 0.01 +
                    orderInfo.elementType * 0.001 + //1-10
                    orderInfo.minorIndex * 0.00001; //1-100
            if (clippingPlanes == null) {
                continue;
            }
            for (let ii = 0; ii < 4; ii++) {
                planeHelper.copy(clippingPlanes[ii]).applyMatrix4(rootMatrixWorld);
                if (planeHelper.distanceToPoint(intersection.point) < 0) {
                    intersects.splice(i, 1);
                    continue outer;
                }
            }
        }
    };
}
