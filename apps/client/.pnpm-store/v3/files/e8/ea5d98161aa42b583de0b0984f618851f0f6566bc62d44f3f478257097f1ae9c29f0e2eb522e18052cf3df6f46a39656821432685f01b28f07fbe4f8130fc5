import { createFlexNodeState } from '../flex/node.js';
import { createHoverPropertyTransformers, setupCursorCleanup } from '../hover.js';
import { computedIsClipped, createGlobalClippingPlanes } from '../clipping.js';
import { createInstancedPanel } from '../panel/instanced-panel.js';
import { applyTransform, computedTransformMatrix } from '../transform.js';
import { createResponsivePropertyTransformers } from '../responsive.js';
import { ElementType, computedOrderInfo, setupRenderOrder } from '../order.js';
import { createActivePropertyTransfomers } from '../active.js';
import { computed, effect, signal, untracked } from '@preact/signals-core';
import { computeAncestorsHaveListeners, computedGlobalMatrix, computedHandlers, computedIsVisible, computedMergedProperties, createNode, keepAspectRatioPropertyTransformer, setupMatrixWorldUpdate, setupPointerEvents, } from './utils.js';
import { alignmentZMap } from '../utils.js';
import { setupLayoutListeners, setupClippedListeners } from '../listeners.js';
import { computedPanelGroupDependencies, } from '../panel/instanced-panel-group.js';
import { createInteractionPanel } from '../panel/instanced-panel-mesh.js';
import { Box3, Material, Mesh, Vector3 } from 'three';
import { darkPropertyTransformers } from '../dark.js';
import { getDefaultPanelMaterialConfig, makeClippedCast } from '../panel/index.js';
import { computedInheritableProperty } from '../properties/index.js';
export function createContent(parentCtx, style, properties, defaultProperties, object, contentContainerRef) {
    const hoveredSignal = signal([]);
    const activeSignal = signal([]);
    const initializers = [];
    const flexState = createFlexNodeState();
    setupCursorCleanup(hoveredSignal, initializers);
    const sizeSignal = signal(new Vector3(1, 1, 1));
    const aspectRatio = computed(() => sizeSignal.value.x / sizeSignal.value.y);
    //properties
    const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
        ...darkPropertyTransformers,
        ...createResponsivePropertyTransformers(parentCtx.root.size),
        ...createHoverPropertyTransformers(hoveredSignal),
        ...createActivePropertyTransfomers(activeSignal),
    }, keepAspectRatioPropertyTransformer, (m) => m.add('aspectRatio', aspectRatio));
    //create node
    createNode(undefined, flexState, parentCtx, mergedProperties, object, true, initializers);
    //transform
    const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentCtx.root.pixelSize);
    applyTransform(parentCtx.root, object, transformMatrix, initializers);
    const globalMatrix = computedGlobalMatrix(parentCtx.childrenMatrix, transformMatrix);
    const isClipped = computedIsClipped(parentCtx.clippingRect, globalMatrix, flexState.size, parentCtx.root.pixelSize);
    const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
    //instanced panel
    const groupDeps = computedPanelGroupDependencies(mergedProperties);
    const backgroundorderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentCtx.orderInfo);
    initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundorderInfo, groupDeps, parentCtx.root.panelGroupManager, globalMatrix, flexState.size, undefined, flexState.borderInset, parentCtx.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
    const orderInfo = computedOrderInfo(undefined, ElementType.Object, undefined, backgroundorderInfo);
    const interactionPanel = createInteractionPanel(backgroundorderInfo, parentCtx.root, parentCtx.clippingRect, flexState.size, globalMatrix, initializers);
    setupMatrixWorldUpdate(true, true, object, parentCtx.root, globalMatrix, initializers, false);
    const handlers = computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal);
    const ancestorsHaveListeners = computeAncestorsHaveListeners(parentCtx, handlers);
    setupPointerEvents(mergedProperties, ancestorsHaveListeners, parentCtx.root, object, initializers, true);
    setupLayoutListeners(style, properties, flexState.size, initializers);
    setupClippedListeners(style, properties, isClipped, initializers);
    return Object.assign(flexState, {
        globalMatrix,
        isClipped,
        isVisible,
        mergedProperties,
        remeasureContent: createMeasureContent(mergedProperties, parentCtx.root, flexState, parentCtx.clippingRect, isVisible, orderInfo, sizeSignal, contentContainerRef, initializers),
        interactionPanel,
        handlers,
        initializers,
    });
}
const box3Helper = new Box3();
const smallValue = new Vector3().setScalar(0.001);
const vectorHelper = new Vector3();
const defaultDepthAlign = 'back';
/**
 * normalizes the content so it has a height of 1
 */
function createMeasureContent(propertiesSignal, root, flexState, parentClippingRect, isVisible, orderInfo, sizeSignal, contentContainerRef, initializers) {
    const clippingPlanes = createGlobalClippingPlanes(root, parentClippingRect);
    const depthAlign = computedInheritableProperty(propertiesSignal, 'depthAlign', defaultDepthAlign);
    const keepAspectRatio = computedInheritableProperty(propertiesSignal, 'keepAspectRatio', true);
    const measuredSize = new Vector3();
    const measuredCenter = new Vector3();
    const updateRenderProperties = (content, visible, renderOrder, depthTest, depthWrite) => {
        if (content == null) {
            return;
        }
        content.visible = visible;
        content.traverse((object) => {
            if (!(object instanceof Mesh)) {
                return;
            }
            object.renderOrder = renderOrder;
            if (!(object.material instanceof Material)) {
                return;
            }
            object.material.depthTest = depthTest;
            object.material.depthWrite = depthWrite;
            object.material.transparent = true;
        });
        root.requestRender();
    };
    const measureContent = () => {
        const content = contentContainerRef.current;
        if (content == null) {
            measuredSize.copy(smallValue);
            measuredCenter.set(0, 0, 0);
            return;
        }
        content.traverse((object) => {
            if (object instanceof Mesh) {
                setupRenderOrder(object, root, orderInfo);
                object.material.clippingPlanes = clippingPlanes;
                object.material.needsUpdate = true;
                object.raycast = makeClippedCast(object, object.raycast, root.object, parentClippingRect, orderInfo);
            }
        });
        const parent = content.parent;
        content.parent = null;
        box3Helper.setFromObject(content);
        box3Helper.getSize(measuredSize).max(smallValue);
        sizeSignal.value = measuredSize;
        if (parent != null) {
            content.parent = parent;
        }
        box3Helper.getCenter(measuredCenter);
        root.requestRender();
    };
    initializers.push(() => effect(() => {
        const properties = propertiesSignal.value;
        updateRenderProperties(contentContainerRef.current, isVisible.value, properties.read('renderOrder', 0), properties.read('depthTest', true), properties.read('depthWrite', false));
        root.requestRender();
    }), (subscriptions) => {
        const content = contentContainerRef.current;
        if (content == null) {
            return subscriptions;
        }
        measureContent();
        subscriptions.push(effect(() => {
            const { size: { value: size }, paddingInset: { value: paddingInset }, borderInset: { value: borderInset }, } = flexState;
            if (size == null || paddingInset == null || borderInset == null) {
                return;
            }
            const [width, height] = size;
            const [pTop, pRight, pBottom, pLeft] = paddingInset;
            const [bTop, bRight, bBottom, bLeft] = borderInset;
            const topInset = pTop + bTop;
            const rightInset = pRight + bRight;
            const bottomInset = pBottom + bBottom;
            const leftInset = pLeft + bLeft;
            const innerWidth = width - leftInset - rightInset;
            const innerHeight = height - topInset - bottomInset;
            const pixelSize = root.pixelSize.value;
            content.scale
                .set(innerWidth * pixelSize, innerHeight * pixelSize, keepAspectRatio.value ? (innerHeight * pixelSize * measuredSize.z) / measuredSize.y : measuredSize.z)
                .divide(measuredSize);
            content.position.copy(measuredCenter).negate();
            content.position.z -= alignmentZMap[depthAlign.value] * measuredSize.z;
            content.position.multiply(content.scale);
            content.position.add(vectorHelper.set((leftInset - rightInset) * 0.5 * pixelSize, (bottomInset - topInset) * 0.5 * pixelSize, 0));
            content.updateMatrix();
            root.requestRender();
        }));
        return subscriptions;
    });
    return () => {
        const properties = propertiesSignal.peek();
        updateRenderProperties(contentContainerRef.current, isVisible.peek(), untracked(() => properties.read('renderOrder', 0)), untracked(() => properties.read('depthTest', true)), untracked(() => properties.read('depthWrite', false)));
        measureContent();
    };
}
